import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  CircularProgress, 
  Button, 
  Stack, 
  Alert, 
  IconButton,
  Chip,
  Tooltip,
  Tabs,
  Tab,
  Skeleton
} from '@mui/material';
import { 
  FileOpen, 
  Download, 
  Fullscreen, 
  Code, 
  Description,
  Image as ImageIcon,
  VideoFile,
  AudioFile,
  Article,
  InsertDriveFile,
  TableChart,
  Slideshow,
  Preview,
  SmartToy,
  Refresh
} from '@mui/icons-material';
import { FileRecord } from '../../hooks/useProjectFiles';
import FileAnalyzer from '../ai/FileAnalyzer';
import { supabase } from '../../lib/supabaseClient';
import { publicUrl } from '../../utils/publicUrl';

interface UniversalFileViewerProps {
  file: FileRecord | null;
  onClose?: () => void;
  fileUrlOverride?: string | null; // Optional prop to override fileUrl (useful for testing)
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

// Tab Panel component for the tabbed interface
function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`file-tabpanel-${index}`}
      aria-labelledby={`file-tab-${index}`}
      style={{ height: '100%', overflow: 'auto' }}
      {...other}
    >
      {value === index && (
        <Box sx={{ height: '100%' }}>
          {children}
        </Box>
      )}
    </div>
  );
}

// File types that benefit from the blob URL approach
const BLOB_FILE_TYPES = ['pdf', 'document', 'image', 'audio', 'video'];

// Lazy load all viewers to reduce initial bundle size
const PDFViewer = lazy(() => import('./PDFViewer'));
const ImageViewer = lazy(() => import('./ImageViewer'));
const TextViewer = lazy(() => import('./TextViewer'));
const CodeViewer = lazy(() => import('./CodeViewer'));
const DocumentViewer = lazy(() => import('./DocumentViewer'));
const VideoViewer = lazy(() => import('./VideoViewer'));
const AudioViewer = lazy(() => import('./AudioViewer'));
const SpreadsheetViewer = lazy(() => import('./SpreadsheetViewer'));

// Maximum time to wait for loading viewers
const LOADING_TIMEOUT_MS = 10000;

const UniversalFileViewer: React.FC<UniversalFileViewerProps> = ({ file, onClose, fileUrlOverride }) => {
  const [fileUrl, setFileUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [processing, setProcessing] = useState(false);
  const [tabValue, setTabValue] = useState(0);
  const [urlType, setUrlType] = useState<'direct' | 'blob' | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [loadStartTime, setLoadStartTime] = useState<number>(0);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [fileExtension, setFileExtension] = useState<string>('');
  const [viewerType, setViewerType] = useState<string | null>(null);
  const [loadTimeout, setLoadTimeout] = useState<NodeJS.Timeout | null>(null);
  
  // Handle tab change
  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  // Create blob URL from direct URL
  const createBlobUrl = useCallback(async (directUrl: string): Promise<string> => {
    console.log(`[UniversalFileViewer] Creating blob URL from: ${directUrl}`);
    
    try {
      // Try with credentials first
      const response = await fetch(directUrl, {
        cache: 'no-store',
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch file: ${response.status} ${response.statusText}`);
      }
      
      const blob = await response.blob();
      
      if (blob.size === 0) {
        throw new Error('File has zero bytes');
      }
      
      console.log(`[UniversalFileViewer] Created blob (${blob.size} bytes, ${blob.type})`);
      const blobUrl = URL.createObjectURL(blob);
      console.log(`[UniversalFileViewer] Created blob URL: ${blobUrl}`);
      return blobUrl;
    } catch (error) {
      console.warn('[UniversalFileViewer] Error creating blob with credentials, trying without:', error);
      
      // Try again without credentials
      const response = await fetch(directUrl, {
        cache: 'no-store',
        mode: 'cors'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch file: ${response.status} ${response.statusText}`);
      }
      
      const blob = await response.blob();
      
      if (blob.size === 0) {
        throw new Error('File has zero bytes');
      }
      
      console.log(`[UniversalFileViewer] Created blob without credentials (${blob.size} bytes, ${blob.type})`);
      const blobUrl = URL.createObjectURL(blob);
      return blobUrl;
    }
  }, []);
  
  // Get file URL when component mounts or file changes
  useEffect(() => {
    // Clear any pending timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    
    const getFile = async () => {
      setLoading(true);
      setError(null);
      setLoadStartTime(Date.now());
      
      if (!file) {
        setFileUrl(null);
        setLoading(false);
        return;
      }
      
      // Set a timeout to show error if loading takes too long
      timeoutRef.current = setTimeout(() => {
        if (loading) {
          console.warn('[UniversalFileViewer] Loading timeout reached - setting fallback error');
          setError('Loading is taking longer than expected. The file may be very large or there might be network issues.');
        }
      }, 15000); // 15 seconds timeout
      
      try {
        // If fileUrlOverride is provided, use it directly (testing mode)
        if (fileUrlOverride) {
          console.log(`[UniversalFileViewer] Using provided URL override: ${fileUrlOverride}`);
          setFileUrl(fileUrlOverride);
          setUrlType('direct');
        } else {
          // Get public URL for file
          const url = publicUrl(`files/${file.storage_path}`);
          console.log(`[UniversalFileViewer] Generated direct URL: ${url}`);
          
          // For file types that benefit from blob URLs, use blob approach to avoid network dependency after initial load
          if (BLOB_FILE_TYPES.includes(file.file_type)) {
            try {
              console.log(`[UniversalFileViewer] Using blob approach for ${file.file_type}`);
              const blobUrl = await createBlobUrl(url);
              setFileUrl(blobUrl);
              setUrlType('blob');
            } catch (blobError) {
              console.error(`[UniversalFileViewer] Blob fetch failed:`, blobError);
              console.log(`[UniversalFileViewer] Falling back to direct URL: ${url}`);
              setFileUrl(url);
              setUrlType('direct');
            }
          } else {
            // For other file types, direct URL is fine
            setFileUrl(url);
            setUrlType('direct');
          }
        }
        
        // Check if file needs processing based on type
        const needsProcessing = ['pdf', 'document', 'spreadsheet'].includes(file.file_type);
        
        if (needsProcessing && file.metadata?.processingStatus === 'pending') {
          setProcessing(true);
          
          // Call analyze-file function to process the file
          try {
            await supabase.functions.invoke('analyze-file', {
              body: { fileId: file.id }
            });
          } catch (processingError) {
            console.error('[UniversalFileViewer] Error processing file:', processingError);
            // Continue showing the file even if processing fails
          } finally {
            setProcessing(false);
          }
        }
      } catch (error) {
        console.error('[UniversalFileViewer] Error fetching file URL:', error);
        setError(`Error loading file: ${error instanceof Error ? error.message : 'Unknown error'}`);
      } finally {
        setLoading(false);
        
        // Clear the timeout if it's still active
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      }
    };
    
    getFile();
    
    // Clean up any blob URLs and timeouts on unmount
    return () => {
      if (fileUrl && fileUrl.startsWith('blob:') && urlType === 'blob') {
        console.log(`[UniversalFileViewer] Revoking blob URL`);
        URL.revokeObjectURL(fileUrl);
      }
      
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [file, createBlobUrl, retryCount, fileUrlOverride]);
  
  // Handle file download
  const handleDownload = async () => {
    if (!file || !fileUrl) return;
    
    try {
      // For blob URLs, we can download directly
      if (fileUrl.startsWith('blob:')) {
        const link = document.createElement('a');
        link.href = fileUrl;
        link.download = file.name;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        // For direct URLs, create a blob first to ensure reliable download with proper filename
        try {
          const blobUrl = await createBlobUrl(fileUrl);
          const link = document.createElement('a');
          link.href = blobUrl;
          link.download = file.name;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          // Clean up the temporary blob URL
          URL.revokeObjectURL(blobUrl);
        } catch (error) {
          console.error('[UniversalFileViewer] Error downloading file:', error);
          // Fall back to direct download if blob creation fails
          window.open(fileUrl, '_blank');
        }
      }
    } catch (error) {
      console.error('[UniversalFileViewer] Error downloading file:', error);
      setError(`Error downloading file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };
  
  // Get icon for file type
  const getFileIcon = () => {
    if (!file) return <InsertDriveFile />;
    
    switch (file.file_type) {
      case 'pdf':
        return <Description />;
      case 'document':
        return <Article />;
      case 'image':
        return <ImageIcon />;
      case 'video':
        return <VideoFile />;
      case 'audio':
        return <AudioFile />;
      case 'code':
        return <Code />;
      case 'spreadsheet':
        return <TableChart />;
      case 'presentation':
        return <Slideshow />;
      default:
        return <InsertDriveFile />;
    }
  };
  
  // Handle retry loading
  const handleRetry = () => {
    console.log('[UniversalFileViewer] Retrying file load');
    setLoadStartTime(Date.now());
    setRetryCount(prev => prev + 1);
  };
  
  // Render appropriate viewer based on file type
  const renderFileViewer = () => {
    if (!file || !fileUrl) {
      return (
        <Box sx={{ 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center', 
          justifyContent: 'center', 
          height: '100%' 
        }}>
          <Typography color="text.secondary" variant="h6">No file selected</Typography>
        </Box>
      );
    }
    
    if (loading) {
      return (
        <Box sx={{ 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center', 
          justifyContent: 'center', 
          height: '100%' 
        }}>
          <CircularProgress size={40} thickness={4} />
          <Typography variant="body1" sx={{ mt: 2 }}>
            Loading {file.file_type}...
          </Typography>
          <Typography variant="caption" color="text.secondary" sx={{ mt: 1 }}>
            {loadStartTime > 0 ? `Time elapsed: ${Math.floor((Date.now() - loadStartTime)/1000)}s` : ''}
          </Typography>
        </Box>
      );
    }
    
    if (error) {
      return (
        <Box sx={{ 
          p: 2, 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center', 
          justifyContent: 'center',
          height: '100%'
        }}>
          <Alert severity="error" sx={{ mb: 2, width: '100%' }}>
            {error}
          </Alert>
          <Button 
            variant="contained" 
            startIcon={<Refresh />} 
            onClick={handleRetry}
            sx={{ mt: 2 }}
          >
            Retry Loading
          </Button>
          
          <Button
            variant="outlined"
            startIcon={<Download />}
            onClick={handleDownload}
            sx={{ mt: 2 }}
          >
            Download File Instead
          </Button>
        </Box>
      );
    }
    
    // Render appropriate viewer based on file type using Suspense for lazy loading
    return (
      <Suspense fallback={
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
          <CircularProgress />
        </Box>
      }>
        {(() => {
          switch (file.file_type) {
            case 'pdf':
              return (
                <Box sx={{ width: '100%', height: '100%', overflow: 'hidden' }}>
                  <PDFViewer 
                    url={fileUrl} 
                    fileName={file.name} 
                    onLoad={() => {
                      console.log('[UniversalFileViewer] PDF loaded successfully');
                      setLoading(false);
                    }}
                    onError={(err) => {
                      console.error('[UniversalFileViewer] PDF load error:', err);
                      setError(`Error displaying PDF: ${err.message}`);
                    }}
                  />
                </Box>
              );
            
            case 'image':
              return (
                <ImageViewer 
                  url={fileUrl} 
                  fileName={file.name} 
                />
              );
            
            case 'video':
              return <VideoViewer url={fileUrl} fileName={file.name} type={file.content_type} />;
            
            case 'audio':
              return <AudioViewer url={fileUrl} fileName={file.name} type={file.content_type} />;
            
            case 'document':
              return <DocumentViewer url={fileUrl} fileName={file.name} fileType={file.content_type} />;
            
            case 'code':
              return <CodeViewer url={fileUrl} fileName={file.name} />;
            
            case 'spreadsheet':
              return <SpreadsheetViewer url={fileUrl} fileName={file.name} />;
            
            default:
              // Generic file viewer with download option
              return (
                <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', p: 4 }}>
                  {getFileIcon()}
                  <Typography variant="body1" sx={{ mt: 2, mb: 3 }}>
                    File preview not available for this file type
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<Download />}
                    onClick={handleDownload}
                  >
                    Download File
                  </Button>
                </Box>
              );
          }
        })()}
      </Suspense>
    );
  };
  
  // File info panel
  const renderFileInfo = () => {
    if (!file) return null;
    
    return (
      <Box sx={{ 
        p: 2, 
        borderBottom: 1, 
        borderColor: 'divider',
        display: 'flex',
        flexDirection: 'column',
        gap: 1 
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {getFileIcon()}
          <Typography variant="h6" noWrap sx={{ maxWidth: '85%' }}>
            {file.name}
          </Typography>
        </Box>
        
        <Stack direction="row" spacing={1} sx={{ flexWrap: 'wrap', gap: 0.5 }}>
          <Chip 
            label={file.file_type.toUpperCase()} 
            size="small" 
            color="primary" 
            variant="outlined" 
          />
          
          <Chip 
            label={`${(file.size / 1024).toFixed(1)} KB`} 
            size="small" 
            variant="outlined" 
          />
          
          {file.exhibit_id && (
            <Chip 
              label={`ID: ${file.exhibit_id}`} 
              size="small" 
              color="secondary" 
              variant="outlined" 
            />
          )}
          
          {urlType && (
            <Chip 
              label={`URL: ${urlType}`} 
              size="small" 
              color="info" 
              variant="outlined" 
            />
          )}
          
          {processing && (
            <Chip 
              label="Processing..." 
              size="small" 
              color="warning" 
              icon={<CircularProgress size={12} />} 
            />
          )}
        </Stack>
      </Box>
    );
  };
  
  // Extract file extension from fileName
  useEffect(() => {
    if (file) {
      const ext = file.name.split('.').pop()?.toLowerCase() || '';
      setFileExtension(ext);
    }
  }, [file]);

  // Determine the appropriate viewer based on file extension or mime type
  useEffect(() => {
    if (!fileUrl) {
      setError('No file URL provided');
      setLoading(false);
      return;
    }

    // Reset states when URL changes
    setLoading(true);
    setError(null);
    
    let viewer: string | null = null;
    
    // PDF files
    if (fileExtension === 'pdf' || file.content_type === 'application/pdf') {
      viewer = 'pdf';
    } 
    // Image files
    else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'].includes(fileExtension) || 
             (file.content_type && file.content_type.startsWith('image/'))) {
      viewer = 'image';
    } 
    // Text files
    else if (['txt', 'md', 'markdown', 'html', 'htm', 'xml', 'csv', 'json'].includes(fileExtension) ||
             (file.content_type && (file.content_type.startsWith('text/') || file.content_type === 'application/json'))) {
      viewer = 'text';
    } 
    // Code files
    else if (['js', 'jsx', 'ts', 'tsx', 'py', 'java', 'c', 'cpp', 'cs', 'go', 'rb', 'php', 
              'sql', 'sh', 'bash', 'css', 'scss', 'less', 'yaml', 'yml'].includes(fileExtension)) {
      viewer = 'code';
    } 
    // Unknown file type - offer download
    else {
      viewer = null;
    }
    
    setViewerType(viewer);
    
    // Set a timeout to prevent endless loading state
    if (loadTimeout) {
      clearTimeout(loadTimeout);
    }
    
    const timeout = setTimeout(() => {
      if (loading) {
        console.warn('File viewer loading timed out');
        setLoading(false);
        setError('Loading timed out. The file might be too large or in an unsupported format.');
      }
    }, LOADING_TIMEOUT_MS);
    
    setLoadTimeout(timeout);
    
    return () => {
      if (loadTimeout) {
        clearTimeout(loadTimeout);
      }
    };
  }, [fileUrl, fileExtension, file.content_type, loadTimeout]);

  // Handle successful file loading
  const handleLoadSuccess = () => {
    setLoading(false);
    setError(null);
    
    if (loadTimeout) {
      clearTimeout(loadTimeout);
    }
  };

  // Handle loading error
  const handleLoadError = (err: Error) => {
    console.error('Error loading file:', err);
    setLoading(false);
    setError(`Failed to load file: ${err.message}`);
    
    if (loadTimeout) {
      clearTimeout(loadTimeout);
    }
  };

  // Fallback component for unsupported file types
  const UnsupportedFileView = () => (
    <Box 
      sx={{ 
        p: 3, 
        display: 'flex', 
        flexDirection: 'column', 
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%'
      }}
      data-test="file-viewer"
    >
      <Typography variant="h6" gutterBottom>
        {file?.name}
      </Typography>
      <Typography color="text.secondary" gutterBottom>
        This file type ({fileExtension || 'unknown'}) cannot be previewed directly.
      </Typography>
      <Button 
        variant="contained" 
        color="primary" 
        href={fileUrl || ''} 
        target="_blank"
        download={file?.name}
        sx={{ mt: 2 }}
      >
        Download File
      </Button>
    </Box>
  );

  // Loading skeleton
  const LoadingSkeleton = () => (
    <Box 
      sx={{ 
        p: 3, 
        display: 'flex', 
        flexDirection: 'column', 
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%'
      }}
    >
      <Skeleton variant="rectangular" width="100%" height="80%" />
      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2, width: '100%' }}>
        <Skeleton variant="rectangular" width="30%" height={36} sx={{ mx: 1 }} />
        <Skeleton variant="rectangular" width="30%" height={36} sx={{ mx: 1 }} />
      </Box>
    </Box>
  );

  return (
    <Paper 
      elevation={3} 
      sx={{ 
        height: '100%', 
        display: 'flex', 
        flexDirection: 'column',
        overflow: 'hidden',
        borderRadius: 2,
        bgcolor: 'background.paper' 
      }}
      data-test="file-viewer"
    >
      {/* File Info */}
      {renderFileInfo()}
      
      {/* Tabs */}
      <Tabs 
        value={tabValue} 
        onChange={handleTabChange}
        aria-label="file viewer tabs"
        sx={{ 
          borderBottom: 1, 
          borderColor: 'divider',
          minHeight: '48px',
          '& .MuiTab-root': {
            minHeight: '48px',
            py: 1
          }
        }}
      >
        <Tab 
          icon={<Preview fontSize="small" />} 
          iconPosition="start" 
          label="Preview" 
          id="file-tab-0"
          aria-controls="file-tabpanel-0"
        />
        <Tab 
          icon={<SmartToy fontSize="small" />} 
          iconPosition="start" 
          label="AI Assist" 
          id="file-tab-1"
          aria-controls="file-tabpanel-1"
          disabled={!file || loading}
        />
      </Tabs>
      
      {/* Preview Tab */}
      <TabPanel value={tabValue} index={0}>
        <Box sx={{ 
          flexGrow: 1, 
          overflow: 'auto', 
          position: 'relative',
          display: 'flex',
          height: '100%',
          bgcolor: 'action.hover' 
        }}>
          {!viewerType ? (
            <UnsupportedFileView />
          ) : (
            <Suspense fallback={<LoadingSkeleton />}>
              {viewerType === 'pdf' && (
                <PDFViewer 
                  url={fileUrl || ''} 
                  title={file?.name || ''}
                  onLoad={handleLoadSuccess}
                  onError={handleLoadError}
                />
              )}
              {viewerType === 'image' && (
                <ImageViewer 
                  url={fileUrl || ''} 
                  alt={file?.name || ''}
                  onLoad={handleLoadSuccess}
                  onError={handleLoadError}
                />
              )}
              {viewerType === 'text' && (
                <TextViewer 
                  url={fileUrl || ''} 
                  fileName={file?.name || ''}
                  onLoad={handleLoadSuccess}
                  onError={handleLoadError}
                />
              )}
              {viewerType === 'code' && (
                <CodeViewer 
                  url={fileUrl || ''} 
                  fileName={file?.name || ''}
                  language={fileExtension}
                  onLoad={handleLoadSuccess}
                  onError={handleLoadError}
                />
              )}
            </Suspense>
          )}
        </Box>
      </TabPanel>
      
      {/* AI Assist Tab */}
      <TabPanel value={tabValue} index={1}>
        <Box sx={{ height: '100%', overflow: 'auto' }}>
          <FileAnalyzer file={file} />
        </Box>
      </TabPanel>
      
      {/* Action Bar */}
      <Box sx={{ 
        p: 1, 
        borderTop: 1, 
        borderColor: 'divider',
        display: 'flex',
        justifyContent: 'space-between' 
      }}>
        <Button
          size="small"
          startIcon={<Download />}
          onClick={handleDownload}
          disabled={!fileUrl}
        >
          Download
        </Button>
        
        <Box>
          <Tooltip title="Retry loading">
            <IconButton size="small" onClick={handleRetry} disabled={!file}>
              <Refresh fontSize="small" />
            </IconButton>
          </Tooltip>
          <Tooltip title="View fullscreen">
            <IconButton size="small">
              <Fullscreen fontSize="small" />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>
    </Paper>
  );
};

export default UniversalFileViewer; 